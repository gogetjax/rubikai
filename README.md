# RubikAI
## Christopher Jackson (@gogetjax)

Thank you for your interest in RubikAI.  It's an excitng problem to
tackle and I find that it also serves as a great playground for
various AI techniques.

This file describes the project layout structure and some quick basics
for running the core program and viewer. For more in-depth information,
please refer to the wiki.

```ignore
-=Directory Structure=-

rubikai/              # Project root directory
\_ core               # Location of the Lisp program which runs rubikai
  \_ src              # All the *.lisp files
\_ simulations        # Several example simulation files (*.rbk)
\_ viewer             # The C++ front-end GUI which runs the simulations
  \_ bin              # Compiled, platform-specific binaries for the viewer
  \_ src              # The actuall C++ source files for the viewer GUI
\_README.txt          # The file you're reading now obviously
\_RESEARCH.txt        # In-depth analysis and observations of algorithms


-= Running the viewer =-
  cd viewer/bin/linux_x86/
  ./rubikai
  # The viewer loads up.
  File -> Load and Run...
  # Load an example output file from rubikai/simulations
  # The animation sequence starts and shows the simulation playback

-= Compiling/Loading the core system =-
  # Load up your favorite Lisp interpreter
  > (load (compile-file "RubikAI.lisp"))

-= Most basic way to run RubikAI =-
  > (simulate)
  # This uses all the defaults (see below)
  # The following is equivalent to the above which uses the default options:
  > (simulate :outfile "rubik-out.rbk"
              :algorithm #'simulated-annealing
              :successor #'novice-successor)
  # Any combination of :algorithm and :successor may be used (see below)

-= The current list of :algorithm and :successor options =-
  :algorithm #'simulated-annealing
  :algorithm #'greedy
  :successor #'random-successor
  :successor #'novice-successor
  :successor #'smart-successor

-= Starting from a specified cube state =-
  By default, (simulate) will generate a random start state for the
  cube by starting from a completed state and making N random moves
  where N is some pre-defined number.  Currently there is no way
  to specify what N is on the "command-line" so to speak, however,
  feel free to edit the source code:

    Look for this line in the (defun simulate ...) function:
    (setf *node* (randomize-cube :iterations 5))
    Then change the parameter to :iterations to any number you'd like.

  You may have noticed that (simulate) can also be passed an ":infile"
  parameter.  This parameter reads in the start state from a specified
  file which is given by the value of :infile. The (cube-from-file) function
  has yet to be implemented.  Stay tuned for this feature in a future release.
  Also in a future release, you will be able to easily setup a customized
  state using the viewer GUI and then export it and use it as the :infile.

-= Making changes to the viewer =-
  Here is a description of the file which make up the viewer
  Makefile         # Linux Makefile generated by qmake which uses gcc/g++
  RubikAI.cpp      # Implementation file of the main window GUI class
  RubikAI.h        # Header file for the main window GUI class
  RubikAI.pro      # The Qt project file created by qmake
  main.cpp         # The instantiated application that runs the viewer
  moc_RubikAI.cpp  # Qt auto-generated file for slots/triggers

  Notice that in the RubikAI.pro project file, you have variables like:
  TARGET, DESTDIR, OBJECTS_DIR, etc.

  By default you can see that it's setup to output the compile binaries
  to the appropriate directory (i.e. rubikai/viewer/bin/linux_x86/)
  (At the moment, there are only Linux binaries, future releases will include
   windows and mac binaries).

  Let's say we want to change the DESTDIR of the executable (TARGET) file
  to $HOME. We would do the following:

  cd viewer/src
  # Open RubikAI.pro in your favorite text-editor
  # EDIT: DESTDIR = $HOME
  # Save changes and close the editor
  qmake  # run qmake with no arguments
  make   # recompile the source
  # That's it! Now you can run your new binary from $HOME
  ~/rubikai  # The viewer loads up.

  Follow a similar edit cycle for any changes made here. You only need
  to run qmake if you edit the *.pro file or add any new source files,
  otherwise you would just need to run the "make" utility.
```

Enjoy!

Follow me on X: [@gogetjax](https://x.com/gogetjax)




